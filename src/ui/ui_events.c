// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"
#include "ui_events.h"
#include "screens.h"
#include "hid_dev.h"
#include "esp_log.h"
#include "stratagems.h"
#include "i2s_player.h"
#include "main.h"
#include "ui_post.h"
#include "configration.h"
#include "actions.h"
#include "ui_assignment.h"
#include "esp_timer.h"

const char *TAG_EVT = "Events";

// User button list
lv_obj_t *buttons[MAX_USER_STRATAGEMS];
// Stratagem list index of user buttons
int indices[MAX_USER_STRATAGEMS];
// Stratagem list index of user buttons
int types[MAX_USER_STRATAGEMS];
// Amount of user assigned stratagems
uint8_t strategemsAmount = 0;

lv_obj_t *cooldownLabels[MAX_USER_STRATAGEMS];
uint64_t cooldownValues[MAX_USER_STRATAGEMS];
extern lv_timer_t *cooldownTimer;

int manualIndex = 0;
int manualList = 0;
int manualSequence[MAX_CMD_LENGTH] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
int manualMatch = -1;
extern bool manualAutoComplete;
extern bool showCooldowns;
lv_timer_t *timerManual = NULL;

lv_timer_t *timerMsg = NULL;
bool presetImageMode = false;
char presetKey[3] = "p0i";

const lv_img_dsc_t *presetImageList[] = {
	&img_icon1,
	&img_icon2,
	&img_icon3,
	&img_icon4,
	&img_icon5,
	&img_icon6,
	&img_mission_conduct_geological_survey,
	&img_mission_emergency_evacuation,
	&img_mission_enable_e_710_extraction,
	&img_mission_eradicate_automaton_forces,
	&img_mission_eradicate_terminid_swarm,
	&img_mission_evacuate_high_value_assets,
	&img_mission_launch_icbm,
	&img_mission_retrieve_essential_personnel,
	&img_mission_retrieve_valuable_data,
	&img_mission_spread_democracy,
	&img_mission_terminate_illegal_broadcast,
	&img_mission_upload_escape_pod_data,
	&img_faction_terminid,
	&img_faction_automaton,
	&img_faction_illuminate};

const lv_img_dsc_t *manualArrowList[] = {
	&img_stratagem_arrow_up1,
	&img_stratagem_arrow_down1,
	&img_stratagem_arrow_left1,
	&img_stratagem_arrow_right1};

// HID input mask for special keys
#define INPUT_CTRL_MASK 1 // 1 CTRL left

// Goto game screen
void action_goto_game(lv_event_t *e)
{
	for (uint8_t c = 0; c < MAX_USER_STRATAGEMS; c++)
	{
		const lv_obj_t *button = buttons[c];
		const lv_img_dsc_t *bgImg = lv_obj_get_style_bg_img_src(button, LV_PART_MAIN | LV_STATE_DEFAULT);
		const bool configured = buttons[c] != NULL;
		lv_obj_t *targetButton = objects.custom_stratagem1;

		bool useHiResIcon = true;

		switch (c)
		{
		case 1:
			targetButton = objects.custom_stratagem2;
			break;
		case 2:
			targetButton = objects.custom_stratagem3;
			break;
		case 3:
			targetButton = objects.custom_stratagem4;
			break;
		case 4:
			targetButton = objects.custom_stratagem5;
			useHiResIcon = false;
			break;
		case 5:
			targetButton = objects.custom_stratagem6;
			useHiResIcon = false;
			break;
		}

		uint8_t itemIndex = indices[c];
		stratagemItem item = strategemItemList[itemIndex];
		const lv_img_dsc_t *hires = useHiResIcon ? item.imgHiRes : bgImg;

		if (configured)
		{
			lv_obj_set_style_border_color(targetButton, lv_color_hex(item.color), LV_PART_MAIN | LV_STATE_DEFAULT);
			lv_obj_set_style_bg_img_src(targetButton, hires, LV_PART_MAIN | LV_STATE_DEFAULT);
			lv_obj_clear_flag(targetButton, LV_OBJ_FLAG_HIDDEN);
		}
		else
		{
			lv_obj_add_flag(targetButton, LV_OBJ_FLAG_HIDDEN);
		}
	}

	lv_scr_load_anim(objects.game, LV_SCR_LOAD_ANIM_MOVE_LEFT, 1000, 0, false);
}

void action_goto_setup(lv_event_t *e)
{
	resetCooldowns();

	lv_timer_pause(cooldownTimer);
}

// Update selection in UI (text and bar)
void updateStratagemSelection()
{
	strategemsAmount = 0;

	for (uint8_t c = 0; c < MAX_USER_STRATAGEMS - 1; c++)
	{
		if (buttons[c] == NULL)
		{
			buttons[c] = buttons[c + 1];
			indices[c] = indices[c + 1];
			types[c] = types[c + 1];

			buttons[c + 1] = NULL;
			indices[c + 1] = -1;
			types[c + 1] = -1;
		}
	}

	for (uint8_t c = 0; c < MAX_USER_STRATAGEMS; c++)
	{
		if (buttons[c] != NULL)
		{
			strategemsAmount++;
		}
	}

	lv_bar_set_value(objects.bar_amount, strategemsAmount, LV_ANIM_OFF);

	int barColor = colorTheme;

	if (strategemsAmount > 0 && strategemsAmount < 4)
	{
		barColor = sgRed;
	}
	else if (strategemsAmount == 4)
	{
		barColor = sgGreen;
	}
	else if (strategemsAmount > 4)
	{
		barColor = sgBlue;
	}

	lv_obj_set_style_bg_color(objects.bar_amount, lv_color_hex(barColor), LV_PART_MAIN | LV_STATE_DEFAULT);
	lv_obj_set_style_bg_color(objects.bar_amount, lv_color_hex(barColor), LV_PART_INDICATOR | LV_STATE_DEFAULT);

	char textAmount[] = "0 / 0";
	textAmount[0] = (char)(strategemsAmount + '0');
	textAmount[4] = (char)(MAX_USER_STRATAGEMS + '0');

	lv_label_set_text(objects.label_amount, (void *)textAmount);

	if (strategemsAmount == MAX_USER_STRATAGEMS)
	{
		action_goto_game(NULL);
	}
}

// Unassign stratagem item from button
void action_deselect_stratagem(lv_event_t *e)
{
	for (uint8_t c = 0; c < MAX_USER_STRATAGEMS; c++)
	{
		if (buttons[c] == e->current_target)
		{
			buttons[c] = NULL;
			indices[c] = -1;
			types[c] = -1;
		}
	}

	updateStratagemSelection();

	playbackSound(SND_DESELECT);
}

// Assign stratagem item from button
void action_select_stratagem(lv_event_t *e)
{
	if (strategemsAmount < MAX_USER_STRATAGEMS)
	{
		for (uint8_t c = 0; c < MAX_USER_STRATAGEMS; c++)
		{
			if (buttons[c] == NULL)
			{
				enum stratagemType type = (enum stratagemType)lv_obj_get_user_data(e->current_target);
				int index = -1;

				for (uint8_t c = 0; c < SG_ITEM_AMOUNT; c++)
				{
					stratagemItem item = strategemItemList[c];

					if (item.type == type)
					{
						index = c;
						break;
					}
				}

				buttons[c] = e->current_target;
				indices[c] = index;
				types[c] = type;
				break;
			}
		}

		updateStratagemSelection();

		playbackSound(SND_SELECT);
	}
	else
	{
		lv_obj_clear_state(e->current_target, LV_STATE_CHECKED);

		playbackSound(SND_DESELECT);
	}
}

// Reset all selected stratagems from user
void action_reset_stratagems(lv_event_t *e)
{
	if (strategemsAmount == 0)
	{
		return;
	}

	for (uint8_t c = 0; c < MAX_USER_STRATAGEMS; c++)
	{
		if (buttons[c] != NULL)
		{
			lv_obj_clear_state(buttons[c], LV_STATE_CHECKED);
			buttons[c] = NULL;
			indices[c] = -1;
			types[c] = -1;
		}
	}

	updateStratagemSelection();

	playbackSound(SND_RESET);
}

// Change connectivity (Bluetooth/USB)
void action_change_connectivity(lv_event_t *e)
{
	uint8_t connectionType = lv_dropdown_get_selected(objects.dd_connectivity);

	setConnectivity(connectionType + 1, false);
}

// Change assigned keymap
void action_change_keymap(lv_event_t *e)
{
	uint8_t keymapIndex = lv_dropdown_get_selected(objects.dd_keymap);

	setKeymap(keymapIndex, false);
}

void _executeStdStratagem(uint8_t *sequence, char *path)
{
	setStratagemCode(sequence, INPUT_CTRL_MASK, false);

	if (path != NULL)
	{
		playbackSound(path);
	}
}

void _executeUserStratagem(uint8_t index)
{
	uint8_t itemIndex = indices[index];
	stratagemItem item = strategemItemList[itemIndex];

	setStratagemCode(item.sequence, INPUT_CTRL_MASK, false);

	if (showCooldowns)
	{
		cooldownValues[index] = getNow() + item.cooldown;

		if(cooldownTimer->paused){
			lv_timer_resume(cooldownTimer);
		}
	}

	char *path = item.soundPath;

	playbackSound(path);
}

// Trigger 1st standard stratagem
void action_trigger_stratagem_base(lv_event_t *e)
{
	int index = (int)e->user_data;
	uint8_t *sequence = (uint8_t *)strategemBaseList[index].sequence;
	char *path = strategemBaseList[index].soundPath;

	_executeStdStratagem(sequence, path);

	if (index >= MAX_USER_STRATAGEMS) // Mission stratagems
	{
		lv_scr_load_anim(objects.game, LV_SCR_LOAD_ANIM_NONE, 0, 0, false);
	}
}

// Trigger 1st user stratagem
void action_trigger_stratagem_user(lv_event_t *e)
{
	int index = (int)e->user_data;

	_executeUserStratagem(index);
}

// Trigger keyboard demo (send "hello" via bluetooth connection to host)
void action_keyboard_demo(lv_event_t *e)
{
	uint8_t sequence[MAX_CMD_LENGTH] = {HID_KEY_H,
										HID_KEY_E,
										HID_KEY_L,
										HID_KEY_L,
										HID_KEY_O,
										0,
										0,
										0,
										0};

	setStratagemCode(sequence, 0, true);
}

char *resolvePresetKey(char presetIndex, int8_t itemIndex)
{
	static char key[3] = "p00";

	char buffer[1];

	if (itemIndex >= 0)
	{
		itoa(itemIndex, buffer, 10);
	}
	else
	{
		buffer[1] = 'i';
	}

	key[1] = presetIndex;
	key[2] = buffer[0];

	return key;
}

void updatePresets()
{
	if (openConfig() != ESP_OK)
	{
		return;
	}

	bool hasPresetList[MAX_USER_PRESETS] = {};

	for (uint8_t c = 0; c < MAX_USER_PRESETS; c++)
	{
		char buffer[1];
		itoa(c + 1, buffer, 10);

		presetKey[1] = buffer[0];
		presetKey[2] = '0';

		hasPresetList[c] = getConfig(presetKey, -1) != -1;
	}

	closeConfig();

	resolvePresetImages();

	lv_obj_t *presetButtons[] = {
		objects.btn_preset1,
		objects.btn_preset2,
		objects.btn_preset3,
		objects.btn_preset4,
		objects.btn_preset5,
		objects.btn_preset6};

	for (uint8_t c = 0; c < MAX_USER_PRESETS; c++)
	{
		lv_obj_set_style_border_color(presetButtons[c], lv_color_hex(hasPresetList[c] ? sgGreen : sgRed), LV_PART_MAIN | LV_STATE_DEFAULT);
	}
}

void action_get_preset(lv_event_t *e)
{
	if (openConfig() != ESP_OK)
	{
		return;
	}

	int userData = (int)e->user_data;

	char buffer[1];
	itoa(userData, buffer, 10);

	presetKey[1] = buffer[0];

	if (presetImageMode)
	{
		presetImageMode = false;

		disableImageMode();

		lv_scr_load_anim(objects.image, LV_SCR_LOAD_ANIM_FADE_IN, 500, 0, false);

		return;
	}

	action_reset_stratagems(NULL);

	for (uint8_t c = 0; c < MAX_USER_STRATAGEMS; c++)
	{
		char *key = resolvePresetKey(presetKey[1], c);

		int8_t presetIndex = getConfig(key, -1);
		types[c] = presetIndex;

		if (presetIndex == -1)
		{
			continue;
		}

		uint8_t listIndex = 0;
		uint16_t childIndex = 0;

		lv_obj_t *lists[8] = {
			objects.tab_rifle,
			objects.tab_special,
			objects.tab_backpack,
			objects.tab_supply,
			objects.tab_sentry,
			objects.tab_ground,
			objects.tab_strike,
			objects.tab_eagle};

		while (1)
		{
			lv_obj_t *child = lv_obj_get_child(lists[listIndex], childIndex);

			if (child == NULL)
			{
				uint8_t listsLength = (uint8_t)sizeof(lists);

				if (listIndex < listsLength)
				{
					listIndex++;
					childIndex = 0;
					continue;
				}

				break;
			}

			enum stratagemType type = (enum stratagemType)lv_obj_get_user_data(child);

			if (type == presetIndex)
			{
				int index = -1;

				for (int c = 0; c < SG_ITEM_AMOUNT; c++)
				{
					stratagemItem item = strategemItemList[c];

					if (item.type == type)
					{
						index = c;
						break;
					}
				}

				buttons[c] = child;
				indices[c] = index;

				lv_obj_add_state(child, LV_STATE_CHECKED);
				break;
			}

			childIndex++;
		}
	}

	closeConfig();

	updateStratagemSelection();

	if (strategemsAmount == 0)
	{
		showMsgBox("Preset\nempty");
	}
	else
	{
		showMsgBox("Preset\nloaded");
	}

	lv_scr_load_anim(objects.setup, LV_SCR_LOAD_ANIM_FADE_IN, 500, 0, false);
}

void action_set_preset(lv_event_t *e)
{
	if (presetImageMode)
	{
		return;
	}

	int userData = (int)e->user_data;

	char buffer[1];
	itoa(userData, buffer, 10);

	presetKey[1] = buffer[0];

	for (uint8_t c = 0; c < MAX_USER_STRATAGEMS; c++)
	{
		char *key = resolvePresetKey(presetKey[1], c);

		setConfig(key, (uint8_t)types[c]);
	}

	updatePresets();

	playbackSound(SND_DESELECT);

	if (strategemsAmount == 0)
	{
		showMsgBox("Preset\ncleared");
	}
	else
	{
		showMsgBox("Preset\nsaved");
	}

	lv_scr_load_anim(objects.setup, LV_SCR_LOAD_ANIM_FADE_IN, 500, 0, false);
}

void showMsgBox(char *msg)
{
	lv_label_set_text(objects.msg_label, msg);
	lv_obj_clear_flag(objects.msg_box, LV_OBJ_FLAG_HIDDEN);

	if (timerMsg != NULL)
	{
		lv_timer_del(timerMsg);
		timerMsg = NULL;
	}

	timerMsg = lv_timer_create(hideMsgBox, 1500, NULL);
}

void hideMsgBox(lv_timer_t *timer)
{
	if (timerMsg != NULL)
	{
		lv_timer_del(timerMsg);
		timerMsg = NULL;
	}

	lv_obj_add_flag(objects.msg_box, LV_OBJ_FLAG_HIDDEN);
}

void enableImageMode()
{
	presetImageMode = lv_obj_has_state(objects.btn_preset_image, LV_STATE_CHECKED);
}

void disableImageMode()
{
	lv_obj_clear_state(objects.btn_preset_image, LV_STATE_CHECKED);
	presetImageMode = false;
}

void action_assign_preset_image(lv_event_t *e)
{
	int userData = (int)e->user_data;

	setConfig(presetKey, (uint8_t)userData);
	resolvePresetImages();

	lv_scr_load_anim(objects.preset, LV_SCR_LOAD_ANIM_FADE_IN, 500, 0, false);
}

void action_clear_preset_image(lv_event_t *e)
{
	setConfig(presetKey, 0);
	resolvePresetImages();

	lv_scr_load_anim(objects.preset, LV_SCR_LOAD_ANIM_FADE_IN, 500, 0, false);
}

void resolvePresetImages()
{
	if (openConfig() != ESP_OK)
	{
		return;
	}

	lv_obj_t *presetButtons[] = {
		objects.btn_preset1,
		objects.btn_preset2,
		objects.btn_preset3,
		objects.btn_preset4,
		objects.btn_preset5,
		objects.btn_preset6};

	for (uint8_t c = 0; c < MAX_USER_PRESETS; c++)
	{
		char buffer[1];
		itoa(c + 1, buffer, 10);

		presetKey[1] = buffer[0];
		presetKey[2] = 'i';

		uint8_t imageIndex = getConfig(presetKey, 0);
		uint8_t offset = imageIndex == 0 ? 0 : 5;

		if (imageIndex == 0)
		{
			imageIndex = c;
		}

		const lv_img_dsc_t *presetImage = presetImageList[imageIndex + offset];
		lv_obj_t *button = presetButtons[c];

		lv_obj_set_style_bg_img_src(button, presetImage, LV_PART_MAIN | LV_STATE_DEFAULT);
	}

	closeConfig();
}

void resetPresets()
{
	if (openConfig() != ESP_OK)
	{
		return;
	}

	for (uint8_t c = 0; c < MAX_USER_PRESETS; c++)
	{
		char buffer[1];
		itoa(c + 1, buffer, 10);

		// Define preset index
		presetKey[1] = buffer[0];

		// Delete image
		presetKey[2] = 'i';
		setConfig(presetKey, 0);

		// Delete stratagems
		presetKey[2] = '0';
		setConfig(presetKey, -1);
	}

	closeConfig();

	updatePresets();
}

void action_manual_execute(lv_event_t *e)
{
	int arrowDirection = (int)e->user_data;

	manualSequence[manualIndex] = arrowDirection;

	if (manualIndex < MAX_CMD_LENGTH - 1)
	{
		manualIndex++;

		lookupManualSequence();
		updateManualSequence();
	}
	else
	{
		finalizeManualExecution();
	}

	if (timerManual != NULL)
	{
		lv_timer_del(timerManual);
		timerManual = NULL;
	}

	int timeout = manualMatch >= 0 ? 1000 : 1500;

	timerManual = lv_timer_create(finalizeManualExecution, timeout, NULL);
}

void finalizeManualExecution()
{
	if (manualMatch >= 0)
	{
		uint8_t *sequence;
		char *soundPath;

		if (manualList == 0)
		{
			stratagemItem item = strategemItemList[manualMatch];
			sequence = item.sequence;
			soundPath = item.soundPath;
		}
		else
		{
			stratagemBase item = strategemBaseList[manualMatch];
			sequence = item.sequence;
			soundPath = item.soundPath;
		}

		_executeStdStratagem(sequence, soundPath);
	}

	manualMatch = -1;
	manualIndex = 0;

	for (uint8_t c = 0; c < MAX_CMD_LENGTH; c++)
	{
		manualSequence[c] = 0;
	}

	lv_obj_set_style_bg_img_src(objects.manual_preview_item, "", LV_PART_MAIN | LV_STATE_DEFAULT);

	updateManualSequence();
}

void updateManualSequence()
{
	lv_obj_t *cmdImages[MAX_CMD_LENGTH] = {
		objects.manual_cmd1,
		objects.manual_cmd2,
		objects.manual_cmd3,
		objects.manual_cmd4,
		objects.manual_cmd5,
		objects.manual_cmd6,
		objects.manual_cmd7,
		objects.manual_cmd8,
		objects.manual_cmd9};

	for (uint8_t c = 0; c < MAX_CMD_LENGTH; c++)
	{
		const uint8_t currentCmd = manualSequence[c];
		lv_obj_t *target = cmdImages[c];

		if (currentCmd > 0)
		{
			const uint8_t imageIndex = currentCmd - 1;
			const lv_img_dsc_t *arrowImage = manualArrowList[imageIndex];

			lv_img_set_src(target, arrowImage);
			lv_obj_clear_flag(target, LV_OBJ_FLAG_HIDDEN);
		}
		else
		{
			lv_obj_add_flag(target, LV_OBJ_FLAG_HIDDEN);
		}
	}
}

void lookupManualSequence()
{
	int matchCount = 0;

	for (uint8_t c1 = 0; c1 < SG_ITEM_AMOUNT; c1++)
	{
		stratagemItem item = strategemItemList[c1];
		bool match = true;
		bool matchComplete = false;

		for (uint8_t c2 = 0; c2 < manualIndex; c2++)
		{
			const uint8_t manualStep = manualSequence[c2];
			matchComplete = c2 < MAX_CMD_LENGTH && item.sequence[c2 + 1] == 0;

			if (item.sequence[c2] != manualStep)
			{
				match = false;
				break;
			}
		}

		if (!manualAutoComplete && !matchComplete)
		{
			match = false;
		}

		if (match)
		{
			manualList = 0;
			matchCount++;
			manualMatch = c1;
		}
	}

	if (matchCount == 0)
	{
		for (uint8_t c1 = 0; c1 < SG_BASE_AMOUNT; c1++)
		{
			stratagemBase item = strategemBaseList[c1];
			bool match = true;
			bool matchComplete = false;

			for (uint8_t c2 = 0; c2 < manualIndex; c2++)
			{
				const uint8_t manualStep = manualSequence[c2];
				matchComplete = c2 < MAX_CMD_LENGTH && item.sequence[c2 + 1] == 0;

				if (item.sequence[c2] != manualStep)
				{
					match = false;
					break;
				}
			}

			if (!manualAutoComplete && !matchComplete)
			{
				match = false;
			}

			if (match)
			{
				manualList = 1;
				matchCount++;
				manualMatch = c1;
			}
		}
	}

	if (matchCount == 1)
	{
		const lv_img_dsc_t *imgHiRes = manualList == 0 ? strategemItemList[manualMatch].imgHiRes : strategemBaseList[manualMatch].imgHiRes;

		if (imgHiRes == NULL)
		{
			return;
		}

		lv_obj_set_style_bg_img_src(objects.manual_preview_item, imgHiRes, LV_PART_MAIN | LV_STATE_DEFAULT);
	}
	else
	{
		manualMatch = -1;

		lv_obj_set_style_bg_img_src(objects.manual_preview_item, "", LV_PART_MAIN | LV_STATE_DEFAULT);
	}
}

void resetCooldowns()
{
	for (uint8_t c = 0; c < MAX_USER_STRATAGEMS; c++)
	{
		lv_obj_add_flag(cooldownLabels[c], LV_OBJ_FLAG_HIDDEN);

		cooldownValues[c] = 0;
	}
}

uint64_t getNow()
{
	return esp_timer_get_time() / 1000000;
}